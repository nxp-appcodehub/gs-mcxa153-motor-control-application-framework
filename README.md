# NXP Application Code Hub
[<img src="https://mcuxpresso.nxp.com/static/icon/nxp-logo-color.svg" width="100"/>](https://www.nxp.com)

## MCXA153 Motor control application framework

Motor control framework was done according to customer requirements for simple and easy to use example to build more complex solutions. In this example there is prepared almost everything  for running 3-phase voltage inverter based applications. There are no additional API for important peripherals, everything is done at low level. There are prepared two interrupts, ADC sampling, FreeMASTER and RTCESL libraries implementations. **This example as is, is not prepared to spin the motor. It is cornerstone to develop an application which will be able to spin the motor.** More details are here in [Application overview](#step5).



#### Boards: FRDM-MCXA153
#### Categories: Motor Control
#### Peripherals: ADC, CLOCKS, GPIO, PWM, TIMER, UART
#### Toolchains: MCUXpresso IDE

## Table of Contents
1. [Software](#step1)
2. [Hardware](#step2)
3. [Setup](#step3)
4. [Results](#step4)
5. [Application overview](#step5) 
6. [FAQs](#step6) 
7. [Support](#step7)
8. [Release Notes](#step8)

## 1. Software<a name="step1"></a>
* Latest [MCUXpresso IDE](https://www.nxp.com/design/design-center/software/development-software/mcuxpresso-software-and-tools-/mcuxpresso-integrated-development-environment-ide:MCUXpresso-IDE)
* MCXA153 SDK including FreeMASTER (Downloadable via MCUXpresso IDE)
* [FreeMASTER realtime debugger](https://www.nxp.com/design/design-center/software/development-software/freemaster-run-time-debugging-tool:FREEMASTER)

## 2. Hardware<a name="step2"></a>
* [FRDM-MCXA153 Development Board](https://www.nxp.com/design/design-center/development-boards-and-designs/FRDM-MCXA153)

[<img src="images/mcxa153board.png" width="300"/>](/images/mcxa153board.png)


* [FRDM-MC-LVPMSM](https://www.nxp.com/design/design-center/development-boards/general-purpose-mcus/nxp-freedom-development-platform-for-low-voltage-3-phase-pmsm-motor-control:FRDM-MC-LVPMSM)

[<img src="images/lvpmsm.png" width="300"/>](/images/lvpmsm.png)

* Power supply adapter 24-48 VDC

## 3. Setup<a name="step3"></a>
For running the example software there is needed to insert FRDM-MC-LVPMSM to the FRDM-MCXA153 board. Without FRDM-MC-LVPMSM the SW will work but the analog measurement by ADC will not give correct numbers because of missing voltage offset from power stage. You could debug the SW within IDE and/or FreeMASTER. 

### 3.1 Step 1
Import the project into the MCUXpresso IDE.

### 3.2 Step 2

Build and flash the project into FRDM-MCXA153 board.

### 3.2 Step 3

Run FreeMASTER .pmpx project from **motor_control** folder and connect to the board.

[<img src="images/free.png" width="800"/>](/images/free.png)

In some cases is necessary to plug out/in EVK USB after flashing or after computer wake up from sleep. After code modification, FreeMASTER pop-ups changes to accept in MAP file.

[<img src="images/free2.png" width="800"/>](/images/free2.png)


## 4. Results<a name="step4"></a>
You could observe live analogue values and correct measurement of DC-bus voltage according to connected power supply level to FRDM-MC-LVPMSM board. After set the `ui16Run` to 1, there should be obvious that calibration procedure correctly detected and subtracted offset on current channels.

## 5. Application Overview<a name="step5"></a>
### 5.1 Peripherals initialization
Initialization functions are located in **mc_periph_init.c** source file.
### 5.2 Ports and pins 
Basic pin initialization uses **BOARD_Init_Pins** function from **board/pin_mux.c** source file generated by the tool.

### 5.3 PWM
There is used **eFlexPWM** module to drive 3-phase Voltage Source Inverter. PWM frequency is configured in **peripheral_init.h.** file by setting `PWM_FREQ` define. 
From this frequency value there is calculated by preprocessor `PWM_MODULO` value for eFlexPWM module.  
PWM is configured to run in symmetric, center-aligned mode. This is done by setting `INIT` register value to `-MODULO/2` and `VAL1` register value to `MODULO/2 – 1`. 
Deadtime value register DTCNTn is configured based on `M1_PWM_DEADTIME`. 
`VAL4` register is used as trigger event for ADC to sample shunt resistors voltage drops during zero vector (all bottom switches are ON). Trigger-out for ADC is enabled in `PWM_TCTRL_OUT_TRIG_EN` register.

[<img src="images/pwm_example_MCFRAMEWORK.svg" width="500"/>](/images/pwm_example_MCFRAMEWORK.svg)

### 5.4 ADC
ADC0 module is initialized in the framework. After enabling of clock there is used default calibration function. In most cases the user wants to update or adjust channel sample sequence. For this purpose there were prepared additional supportive defines which helps to understand command configuration of this kind of ADC.

#### 5.4.1 ADC commands
The main misunderstanding of low level coding of command sequence is numbering offset of actual and next command by configuring CMDL and CMDH registers. For this purpose there were defined actual commands (ACT_CMDx) and next commands (NEXT_CMDy) in **mcxa153_lowlevel_adc.h**.
By using them the low level configuration is more clear for user because numbering offset is masked by the name of defines. Additional defines were created to express configuration parameters according to reference manual, see mcxa153_lowlevel_adc.h
```
ADC0->CMD[ACT_CMD1].CMDL =  ADC_CMDL_ADCH(20U)
                        |   ADC_CMDL_CTYPE(CMDL_CTYPE_SINGLE_ENDED_A)
                        |   ADC_CMDL_MODE(CMDL_MODE_STANDARD);

ADC0->CMD[ACT_CMD1].CMDH =  ADC_CMDH_CMPEN(0)
                        |   ADC_CMDH_WAIT_TRIG(0)
                        |   ADC_CMDH_LWI(0)
                        |   ADC_CMDH_STS(CMDH_SAMPLETIME_3_5)
                        |   ADC_CMDH_AVGS(CMDH_AVERAGE_1)
                        |   ADC_CMDH_LOOP(0)
                        |   ADC_CMDH_NEXT(NEXT_CMD2);

```
#### 5.4.2 ADC FIFO
The important part initialization is FIFO configuration. The MCXA153 has one FIFO which is used to store results from ADC channels.

It is important to know how many results will be in result FIFOs. For this purpose there is also necessary to set right watermark for ADC interrupt.
There is recommended to read number of results in FIFOs (before reading the FIFOs) and compare them with expected number of configured conversions.

#### 5.4.3 LPCMP
Low Power Comparator is set to continuous mode. MSEL mux is set to internal 8-bit DAC. PSEL mux is set to channel 3 which is in our case DC-bus current. LPCMP output is routed as fault into eFlexPWM module.

#### 5.4.4 CTIMER
Ctimer 0 is used as slow loop (1kHz) periodic timer with interrupt.

#### 5.4.5 INPUTMUX
This mux allows to route signals between peripherals. In project it is configured by using Pins Tool. Routed signal is displayed as n/a pin.

[<img src="images/mux.png" width="500"/>](/images/mux.png)

### 5.5 ADC results handling

In the example for better understanding of ADC capabilities, the ADC results are stored into 32-bit variables to observe additional status bits. 32-bit results are then masked with `ADC_RESFIFO_D_MASK` and stored into 16-bit variables. For particular results there is subtracted an offset and used RTCESL shift to full 16-bit scale.
ADC results are stored and conditioned in `AdcGetResults()` function.  

### 5.6 Application state machine

Application state machine is realized as array of pointers to this application state functions.
````
typedef void (*tPointerFcn)(void); /* pointer to function */

static tPointerFcn AppStateMachineFast[] = {AppInitFast,AppStopFast,AppStartFast,AppRunFast,AppErrorFast};
````
There are two state machines calls in **main.c** source code:
`AppStateMachineSlow` in CTIMER ISR (slow loop)
`AppStateMachineFast` in ADC ISR (fast loop)

Particular state machine functions are placed in **motor_control.c**, most of them are empty excluding INIT, STOP and RUN state of fast loop. State is controlled and indicated by variable `ui8MotorState` which is used for both state machines. Change of the state variable is strictly done in transition functions. 
Transition functions are not part of the array pointers, they are independent and easy to rewrite and update according to required user transitions.

In INIT state of fast loop there is example of variables initialization. In stop state of fast loop, the application is waiting for `ui16Run > 0` condition. Then it goes through transition to START state.
START state is intended for e.g. alignment purposes goes to RUN according to state diagram.

[<img src="images/statemachine.svg" width="300"/>](/images/statemachine.svg)


## 6. FAQs<a name="step6"></a>
No FAQs have been identified for this project.

## 7. Support<a name="step7"></a>


#### Project Metadata

<!----- Boards ----->
[![Board badge](https://img.shields.io/badge/Board-FRDM&ndash;MCXA153-blue)]()

<!----- Categories ----->
[![Category badge](https://img.shields.io/badge/Category-MOTOR%20CONTROL-yellowgreen)](https://mcuxpresso.nxp.com/appcodehub?category=motor_control)

<!----- Peripherals ----->
[![Peripheral badge](https://img.shields.io/badge/Peripheral-ADC-yellow)](https://mcuxpresso.nxp.com/appcodehub?peripheral=adc)
[![Peripheral badge](https://img.shields.io/badge/Peripheral-CLOCKS-yellow)](https://mcuxpresso.nxp.com/appcodehub?peripheral=clocks)
[![Peripheral badge](https://img.shields.io/badge/Peripheral-GPIO-yellow)](https://mcuxpresso.nxp.com/appcodehub?peripheral=gpio)
[![Peripheral badge](https://img.shields.io/badge/Peripheral-PWM-yellow)](https://mcuxpresso.nxp.com/appcodehub?peripheral=pwm)
[![Peripheral badge](https://img.shields.io/badge/Peripheral-TIMER-yellow)](https://mcuxpresso.nxp.com/appcodehub?peripheral=timer)
[![Peripheral badge](https://img.shields.io/badge/Peripheral-UART-yellow)](https://mcuxpresso.nxp.com/appcodehub?peripheral=uart)

<!----- Toolchains ----->
[![Toolchain badge](https://img.shields.io/badge/Toolchain-MCUXPRESSO%20IDE-orange)](https://mcuxpresso.nxp.com/appcodehub?toolchain=mcux)

Questions regarding the content/correctness of this example can be entered as Issues within this GitHub repository.

>**Warning**: For more general technical questions regarding NXP Microcontrollers and the difference in expected functionality, enter your questions on the [NXP Community Forum](https://community.nxp.com/)

[![Follow us on Youtube](https://img.shields.io/badge/Youtube-Follow%20us%20on%20Youtube-red.svg)](https://www.youtube.com/NXP_Semiconductors)
[![Follow us on LinkedIn](https://img.shields.io/badge/LinkedIn-Follow%20us%20on%20LinkedIn-blue.svg)](https://www.linkedin.com/company/nxp-semiconductors)
[![Follow us on Facebook](https://img.shields.io/badge/Facebook-Follow%20us%20on%20Facebook-blue.svg)](https://www.facebook.com/nxpsemi/)
[![Follow us on Twitter](https://img.shields.io/badge/X-Follow%20us%20on%20X-black.svg)](https://x.com/NXP)

## 8. Release Notes<a name="step8"></a>
| Version | Description / Update                           | Date                        |
|:-------:|------------------------------------------------|----------------------------:|
| 1.0     | Initial release on Application Code Hub        | April 4<sup>th</sup> 2025 |

<small>
<b>Trademarks and Service Marks</b>: There are a number of proprietary logos, service marks, trademarks, slogans and product designations ("Marks") found on this Site. By making the Marks available on this Site, NXP is not granting you a license to use them in any fashion. Access to this Site does not confer upon you any license to the Marks under any of NXP or any third party's intellectual property rights. While NXP encourages others to link to our URL, no NXP trademark or service mark may be used as a hyperlink without NXP’s prior written permission. The following Marks are the property of NXP. This list is not comprehensive; the absence of a Mark from the list does not constitute a waiver of intellectual property rights established by NXP in a Mark.
</small>
<br>
<small>
NXP, the NXP logo, NXP SECURE CONNECTIONS FOR A SMARTER WORLD, Airfast, Altivec, ByLink, CodeWarrior, ColdFire, ColdFire+, CoolFlux, CoolFlux DSP, DESFire, EdgeLock, EdgeScale, EdgeVerse, elQ, Embrace, Freescale, GreenChip, HITAG, ICODE and I-CODE, Immersiv3D, I2C-bus logo , JCOP, Kinetis, Layerscape, MagniV, Mantis, MCCI, MIFARE, MIFARE Classic, MIFARE FleX, MIFARE4Mobile, MIFARE Plus, MIFARE Ultralight, MiGLO, MOBILEGT, NTAG, PEG, Plus X, POR, PowerQUICC, Processor Expert, QorIQ, QorIQ Qonverge, RoadLink wordmark and logo, SafeAssure, SafeAssure logo , SmartLX, SmartMX, StarCore, Symphony, Tower, TriMedia, Trimension, UCODE, VortiQa, Vybrid are trademarks of NXP B.V. All other product or service names are the property of their respective owners. © 2021 NXP B.V.
</small>
